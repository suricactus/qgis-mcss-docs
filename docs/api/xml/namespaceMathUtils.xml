<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespaceMathUtils" kind="namespace" language="C++">
    <compoundname>MathUtils</compoundname>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceMathUtils_1a54d06f819763561d0b251e1b1151dfc4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::angle</definition>
        <argsstring>(QgsPoint *p1, QgsPoint *p2, QgsPoint *p3, QgsPoint *p4)</argsstring>
        <name>angle</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p3</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p4</declname>
        </param>
        <briefdescription>
<para>Calculates the angle between two segments (in 2 dimension, z-values are ignored) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="78" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="786" bodyend="800"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a5273bed1299606eff74131f8a21d4f1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::BarycentricToXY</definition>
        <argsstring>(double u, double v, double w, QgsPoint *p1, QgsPoint *p2, QgsPoint *p3, QgsPoint *result)</argsstring>
        <name>BarycentricToXY</name>
        <param>
          <type>double</type>
          <declname>u</declname>
        </param>
        <param>
          <type>double</type>
          <declname>v</declname>
        </param>
        <param>
          <type>double</type>
          <declname>w</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p3</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="32" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="50" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1ac9d954f75b62fa0f521c48fd1488272a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::calcBarycentricCoordinates</definition>
        <argsstring>(double x, double y, QgsPoint *p1, QgsPoint *p2, QgsPoint *p3, QgsPoint *result)</argsstring>
        <name>calcBarycentricCoordinates</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>double</type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p3</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
<para>Calculates the barycentric coordinates of a point (x,y) with respect to p1, p2, p3 and stores the three barycentric coordinates in &apos;result&apos;. Thus the u-coordinate is stored in result::x, the v-coordinate in result::y and the w-coordinate in result::z. Attention: p1, p2 and p3 have to be ordered counterclockwise. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="31" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="22" bodyend="48"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a2c8220faa7125fe18eae591b64d8f175" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::calcBernsteinPoly</definition>
        <argsstring>(int n, int i, double t)</argsstring>
        <name>calcBernsteinPoly</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Calculates the value of a Bernstein polynomial. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="34" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="101" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1aca693235b3936f4241d55dccb6e100b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::calcCubicHermitePoly</definition>
        <argsstring>(int n, int i, double t)</argsstring>
        <name>calcCubicHermitePoly</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Calculates the value of a cubic Hermite polynomial. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="38" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="433" bodyend="464"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a93827eeddec33ba9b09d04a4107d97d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::cFDerBernsteinPoly</definition>
        <argsstring>(int n, int i, double t)</argsstring>
        <name>cFDerBernsteinPoly</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Calculates the first derivative of a Bernstein polynomial with respect to the parameter t. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="36" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="111" bodyend="114"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a96ce07512124c5ed7286d38ff5406635" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::cFDerCubicHermitePoly</definition>
        <argsstring>(int n, int i, double t)</argsstring>
        <name>cFDerCubicHermitePoly</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Calculates the first derivative of a cubic Hermite polynomial with respect to the parameter t. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="40" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="466" bodyend="503"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a87493cf9ae1ae89975010b8f9350a22a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::circumcenter</definition>
        <argsstring>(QgsPoint *p1, QgsPoint *p2, QgsPoint *p3, QgsPoint *result)</argsstring>
        <name>circumcenter</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p3</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
<para>Calculates the center of the circle passing through p1, p2 and p3. Returns true in case of success and false otherwise (e.g. all three points on a line) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="42" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="116" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a6d846464f23f7e88477dc5926a082a63" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::crossVec</definition>
        <argsstring>(QgsPoint *first, Vector3D *vec1, QgsPoint *second, Vector3D *vec2)</argsstring>
        <name>crossVec</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>vec1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>second</declname>
        </param>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>vec2</declname>
        </param>
        <briefdescription>
<para>Calculates the intersection of the two vectors vec1 and vec2, which start at first(vec1) and second(vec2) end. The return value is t2(multiplication of v2 with t2 and adding to &apos;second&apos; results the intersection point) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="64" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="650" bodyend="678"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a1eb58aba13cd223083be57bc0204ab65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::derVec</definition>
        <argsstring>(const Vector3D *v1, const Vector3D *v2, Vector3D *result, double x, double y)</argsstring>
        <name>derVec</name>
        <param>
          <type>const <ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type>const <ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>v2</declname>
        </param>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>result</declname>
        </param>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>double</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>Calculates the z-component of a vector with coordinates &apos;x&apos; and &apos;y&apos;which is in the same tangent plane as the tangent vectors &apos;v1&apos; and &apos;v2&apos;. The result is assigned to &apos;result&apos;. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="62" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="505" bodyend="517"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1ab01b2d45b8363e4f0fa78d380f3e039f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::distPointFromLine</definition>
        <argsstring>(QgsPoint *thepoint, QgsPoint *p1, QgsPoint *p2)</argsstring>
        <name>distPointFromLine</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>thepoint</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Calculates the (2 dimensional) distance from &apos;thepoint&apos; to the line defined by p1 and p2. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="44" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="201" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a471223ca81c77dbee4aaa3634b5fab13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int ANALYSIS_EXPORT</type>
        <definition>int MathUtils::faculty</definition>
        <argsstring>(int n)</argsstring>
        <name>faculty</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Faculty function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="46" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="221" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1adb9679ec8d078309f4c991dda20f729a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::inCircle</definition>
        <argsstring>(QgsPoint *testp, QgsPoint *p1, QgsPoint *p2, QgsPoint *p3)</argsstring>
        <name>inCircle</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>testp</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p3</declname>
        </param>
        <briefdescription>
<para>Tests, whether &apos;testp&apos; is inside the circle through &apos;p1&apos;, &apos;p2&apos; and &apos;p3&apos;. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="48" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="226" bodyend="264"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a19ff746de07404e129026ba0f8f583b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::inDiametral</definition>
        <argsstring>(QgsPoint *p1, QgsPoint *p2, QgsPoint *point)</argsstring>
        <name>inDiametral</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>point</declname>
        </param>
        <briefdescription>
<para>Tests, whether &apos;point&apos; is inside the diametral circle through &apos;p1&apos; and &apos;p2&apos;. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="50" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="266" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a9e4901a73d9797883a106197fca1228e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::leftOf</definition>
        <argsstring>(const QgsPoint &amp;thepoint, const QgsPoint *p1, const QgsPoint *p2)</argsstring>
        <name>leftOf</name>
        <param>
          <type>const <ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> &amp;</type>
          <declname>thepoint</declname>
        </param>
        <param>
          <type>const <ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>const <ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Returns whether &apos;thepoint&apos; is left or right of the line from &apos;p1&apos; to &apos;p2&apos;. Negativ values mean left and positiv values right. There may be numerical instabilities, so a threshold may be useful. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="52" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="292" bodyend="309"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a719b1be5d117dd4373e372e7923a8c65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::lineIntersection</definition>
        <argsstring>(QgsPoint *p1, QgsPoint *p2, QgsPoint *p3, QgsPoint *p4)</argsstring>
        <name>lineIntersection</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p3</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p4</declname>
        </param>
        <briefdescription>
<para>Returns true, if line1 (p1 to p2) and line2 (p3 to p4) intersect. If the lines have an endpoint in common, false is returned. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="54" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="311" bodyend="352"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a115ea7f968c85f3f7ec0f613b2db455a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::lineIntersection</definition>
        <argsstring>(QgsPoint *p1, QgsPoint *p2, QgsPoint *p3, QgsPoint *p4, QgsPoint *intersection_point)</argsstring>
        <name>lineIntersection</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p3</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p4</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>intersection_point</declname>
        </param>
        <briefdescription>
<para>Returns true, if line1 (p1 to p2) and line2 (p3 to p4) intersect. If the lines have an endpoint in common, false is returned. The intersecting point is stored in &apos;intersection_point. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="56" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="354" bodyend="405"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a7d37f9974122a952deac28efadcf2f9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int ANALYSIS_EXPORT</type>
        <definition>int MathUtils::lower</definition>
        <argsstring>(int n, int i)</argsstring>
        <name>lower</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>Lower function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="58" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="407" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1af624c9f0a8bceb5575d2e7a1783a17f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void ANALYSIS_EXPORT</type>
        <definition>void MathUtils::normalFromPoints</definition>
        <argsstring>(QgsPoint *p1, QgsPoint *p2, QgsPoint *p3, Vector3D *vec)</argsstring>
        <name>normalFromPoints</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p3</declname>
        </param>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>Calculates the normal vector of the plane through the points p1, p2 and p3 and assigns the result to vec. If the points are ordered counterclockwise, the normal will have a positive z-coordinate;. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="70" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="632" bodyend="648"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a19e9eac235fb2db197d6899f5facad32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::normalLeft</definition>
        <argsstring>(Vector3D *v1, Vector3D *result, double length)</argsstring>
        <name>normalLeft</name>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>result</declname>
        </param>
        <param>
          <type>double</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Assigns the vector &apos;result&apos;, which is normal to the vector &apos;v1&apos;, on the left side of v1 and has length &apos;length&apos;. This method works only with two dimensions. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="66" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="520" bodyend="572"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1afcbb058467422141cc9f6ec608cd7ae1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::normalMinDistance</definition>
        <argsstring>(Vector3D *tangent, Vector3D *target, Vector3D *result)</argsstring>
        <name>normalMinDistance</name>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>tangent</declname>
        </param>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>target</declname>
        </param>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
<para>Calculates a Vector orthogonal to &apos;tangent&apos; with length 1 and closest possible to result. Returns true in case of success and false otherwise. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="74" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="698" bodyend="766"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a6d58942472f6910c5ef57e15127728d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::normalRight</definition>
        <argsstring>(Vector3D *v1, Vector3D *result, double length)</argsstring>
        <name>normalRight</name>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>v1</declname>
        </param>
        <param>
          <type><ref refid="classVector3D" kindref="compound">Vector3D</ref> *</type>
          <declname>result</declname>
        </param>
        <param>
          <type>double</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Assigns the vector &apos;result&apos;, which is normal to the vector &apos;v1&apos;, on the right side of v1 and has length &apos;length&apos;. The calculation is only in two dimensions. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="68" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="576" bodyend="629"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a8654059bd97d42648e6f1c1a0f75e5a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::planeTest</definition>
        <argsstring>(QgsPoint *test, QgsPoint *pt1, QgsPoint *pt2, QgsPoint *pt3)</argsstring>
        <name>planeTest</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>test</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>pt1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>pt2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>pt3</declname>
        </param>
        <briefdescription>
<para>Tests, if &apos;test&apos; is in the same plane as &apos;p1&apos;, &apos;p2&apos; and &apos;p3&apos; and returns the z-difference from the plane to &apos;test. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="76" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="769" bodyend="784"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a673a26afdff096c49860912e596abb09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool ANALYSIS_EXPORT</type>
        <definition>bool MathUtils::pointInsideTriangle</definition>
        <argsstring>(double x, double y, QgsPoint *p1, QgsPoint *p2, QgsPoint *p3)</argsstring>
        <name>pointInsideTriangle</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>double</type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>p3</declname>
        </param>
        <briefdescription>
<para>Returns true, if the point with coordinates x and y is inside (or at the edge) of the triangle p1,p2,p3 and false, if it is outside. p1, p2 and p3 have to be ordered counterclockwise. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="72" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="680" bodyend="696"/>
      </memberdef>
      <memberdef kind="function" id="namespaceMathUtils_1a58e672ede785bc33e08540a848c3794f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double ANALYSIS_EXPORT</type>
        <definition>double MathUtils::triArea</definition>
        <argsstring>(QgsPoint *pa, QgsPoint *pb, QgsPoint *pc)</argsstring>
        <name>triArea</name>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>pa</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>pb</declname>
        </param>
        <param>
          <type><ref refid="classQgsPoint" kindref="compound">QgsPoint</ref> *</type>
          <declname>pc</declname>
        </param>
        <briefdescription>
<para>Returns the area of a triangle. If the points are ordered counterclockwise, the value will be positiv. If they are ordered clockwise, the value will be negativ. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="60" column="1" bodyfile="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.cpp" bodystart="419" bodyend="431"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/suricactus/work/qgis/QGIS/src/analysis/interpolation/MathUtils.h" line="29" column="1"/>
  </compounddef>
</doxygen>
